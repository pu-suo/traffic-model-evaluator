<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Traffic Forecast Evaluation</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/leaflet.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/leaflet.js"></script>
</head>
<body>

    <h1>Traffic Forecast Evaluation Dashboard</h1>
    <p>Select parameters to evaluate a forecasting model against historical data.
    Evaluation is performed for all available sensors for the *single* future time step requested.</p>

    <form id="evalForm">
        <div>
            <label for="prediction_start_time">Prediction Start Time (PST):</label>
            <input type="datetime-local" id="prediction_start_time" name="prediction_start_time" required step="300">
            <small>Your local time (assumed to be PST). Will be converted to UTC for processing.</small>
        </div>

        <div>
            <label for="lookback_minutes">Lookback Period (minutes):</label>
            <input type="number" id="lookback_minutes" name="lookback_minutes" value="60" min="15" max="10080" step="5" required>
            <small>Range: 15 - 10080 (7 days). ARIMA needs at least 50 mins.</small>
        </div>

        <div>
            <label for="horizon_minutes">Prediction Horizon (minutes):</label>
            <input type="number" id="horizon_minutes" name="horizon_minutes" value="15" min="5" max="180" step="5" required>
            <small>The *single* future timestamp to predict (e.g., 15 minutes out). Range: 5 - 180.</small>
        </div>

        <div>
            <label for="model_type">Model Type:</label>
            <select id="model_type" name="model_type" required>
                <option value="HA">Historical Average (HA)</option>
                <option value="ARIMA">ARIMA</option>
            </select>
        </div>

        <button type="submit">Evaluate Model</button>
    </form>

    <div id="loading">Evaluating... Please wait. This may take a minute.</div>
    
    <div id="results">
        <h2>Results</h2>
        <div id="resultsContent"><p>Enter parameters above and click "Evaluate Model".</p></div>
        
        <div id="mapContainer"></div>
        <div id="tableContainer"></div>
    </div>

    <script>
        const form = document.getElementById('evalForm');
        const resultsContentDiv = document.getElementById('resultsContent');
        const loadingDiv = document.getElementById('loading');
        // --- NEW: Get new containers ---
        const mapContainer = document.getElementById('mapContainer');
        const tableContainer = document.getElementById('tableContainer');

        // --- Helper Function to Format Results (COMPLETELY REWRITTEN) ---
        function displayResults(resultData) {
            // Clear all previous results
            resultsContentDiv.innerHTML = '';
            mapContainer.innerHTML = '';
            tableContainer.innerHTML = '';

            if (!resultData || typeof resultData !== 'object') {
                 resultsContentDiv.innerHTML = '<p class="error">Invalid response format received from server.</p>';
                 return;
            }
            if (resultData.error) {
                 resultsContentDiv.innerHTML = `<p class="error">Error: ${resultData.error}</p>`;
                 return;
            }

            // --- 1. Display Overall Metrics ---
            const overall = resultData.overall_metrics;
            let overallHtml = '<h3>Overall Metrics</h3>';
            if (overall && overall.total_points_compared > 0) {
                overallHtml += `<p>
                    Avg MAE: ${overall.mae !== null ? overall.mae.toFixed(2) : 'N/A'} |
                    Avg RMSE: ${overall.rmse !== null ? overall.rmse.toFixed(2) : 'N/A'} |
                    Avg Bias: ${overall.bias !== null ? overall.bias.toFixed(2) : 'N/A'} <br>
                    <small>(Based on ${overall.total_points_compared} comparison points across ${overall.sensors_with_results} / ${overall.sensors_evaluated} sensors)</small>
                </p>`;
            } else {
                overallHtml += '<p>N/A (No comparable points found across sensors or calculation failed)</p>';
            }
            resultsContentDiv.innerHTML = overallHtml; // Put this in the main results div

            // --- 2. Display Maps ---
            if (resultData.maps) {
                mapContainer.innerHTML = '<h3>Geospatial Results</h3>';
                if (resultData.maps.predicted) {
                    mapContainer.innerHTML += resultData.maps.predicted;
                }
                if (resultData.maps.actual) {
                    mapContainer.innerHTML += resultData.maps.actual;
                }
            }
            
            // --- 3. Display Per-Sensor Table ---
            const perSensor = resultData.per_sensor_results;
            let tableHtml = '<h3>All Sensor Results</h3>';
            if (perSensor) {
                tableHtml += '<div class="sensor-details-container">'; // Make it scrollable
                tableHtml += '<table style="width: 100%; border-collapse: collapse;">';
                tableHtml += `
                    <thead style="position: sticky; top: 0; background-color: #f1f1f1;">
                        <tr>
                            <th style="padding: 8px; border-bottom: 1px solid #ddd; text-align: left;">Sensor ID</th>
                            <th style="padding: 8px; border-bottom: 1px solid #ddd; text-align: left;">Prediction (mph)</th>
                            <th style="padding: 8px; border-bottom: 1px solid #ddd; text-align: left;">Actual (mph)</th>
                            <th style="padding: 8px; border-bottom: 1px solid #ddd; text-align: left;">Bias (mph)</th>
                        </tr>
                    </thead>`;
                tableHtml += '<tbody>';
                
                // Sort sensors by ID
                const sortedSensorIds = Object.keys(perSensor).sort();

                for (const sensorId of sortedSensorIds) {
                    const data = perSensor[sensorId];
                    const pred = data.prediction !== null ? data.prediction.toFixed(2) : 'N/A';
                    const actual = data.actual !== null ? data.actual.toFixed(2) : 'N/A';
                    const bias = data.bias !== null ? data.bias.toFixed(2) : 'N/A';
                    
                    tableHtml += `
                        <tr>
                            <td style="padding: 8px; border-bottom: 1px solid #ddd;">${sensorId}</td>
                            <td style="padding: 8px; border-bottom: 1px solid #ddd;">${pred}</td>
                            <td style="padding: 8px; border-bottom: 1px solid #ddd;">${actual}</td>
                            <td style="padding: 8px; border-bottom: 1px solid #ddd;">${bias}</td>
                        </tr>`;
                }
                tableHtml += '</tbody></table></div>';
                tableContainer.innerHTML = tableHtml;
            } else {
                 tableContainer.innerHTML = '<p>No per-sensor results available.</p>';
            }
        }


        // --- Set Default Start Time (Unchanged) ---
        function setDefaultTime() {
            const now = new Date();
            const oneHourAgo = new Date(now.getTime() - (60 * 60 * 1000));
            const minutesRemainder = oneHourAgo.getMinutes() % 5;
            oneHourAgo.setMinutes(oneHourAgo.getMinutes() - minutesRemainder);
            oneHourAgo.setSeconds(0);
            oneHourAgo.setMilliseconds(0);
            const year = oneHourAgo.getFullYear();
            const month = (oneHourAgo.getMonth() + 1).toString().padStart(2, '0');
            const day = oneHourAgo.getDate().toString().padStart(2, '0');
            const hours = oneHourAgo.getHours().toString().padStart(2, '0');
            const minutes = oneHourAgo.getMinutes().toString().padStart(2, '0');
            const localTimeString = `${year}-${month}-${day}T${hours}:${minutes}`;
            const startTimeInput = document.getElementById('prediction_start_time');
            if (startTimeInput) {
                startTimeInput.value = localTimeString;
                console.log("Default start time set to:", localTimeString);
            } else {
                 console.error("Could not find start time input element");
            }
        }

        // --- Form Submission Handler (MODIFIED) ---
        form.addEventListener('submit', async (event) => {
            event.preventDefault();
            // Clear all results and show loading
            resultsContentDiv.innerHTML = '<p>Processing request...</p>';
            mapContainer.innerHTML = '';
            tableContainer.innerHTML = '';
            loadingDiv.style.display = 'block';

            const formData = new FormData(form);
            const startTimeLocal = formData.get('prediction_start_time'); // "YYYY-MM-DDTHH:MM"
            const lookback = parseInt(formData.get('lookback_minutes'), 10);
            const horizon = parseInt(formData.get('horizon_minutes'), 10);
            const model = formData.get('model_type');

            // --- MODIFIED: Send the naive local time string directly ---
            const payload = {
                prediction_start_time_iso: startTimeLocal, // e.g., "2025-10-30T14:05"
                lookback_minutes: lookback,
                horizon_minutes: horizon,
                model_type: model
            };
            console.log("Sending payload:", payload);

            try {
                const response = await fetch('/evaluate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload),
                });

                const result = await response.json();
                console.log("Received response:", result);

                loadingDiv.style.display = 'none';
                displayResults(result); // Call helper to render all new components

            } catch (error) {
                loadingDiv.style.display = 'none';
                console.error('Fetch error:', error);
                resultsContentDiv.innerHTML = `<p class="error">Client-side error: ${error.message}. Check browser console and network tab.</p>`;
            }
        });

        // Set default time when the page loads
        document.addEventListener('DOMContentLoaded', setDefaultTime);
    </script>

</body>
</html>